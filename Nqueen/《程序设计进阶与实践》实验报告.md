### 《程序设计进阶与实践》实验报告

姓名：李宁			学号：PB21111715			日期：2022 年 4 月 2 日

**实验名称**：N皇后问题的求解

**代码语言**：C语言

**实验环境**：CPU：Core i7-11800H 2.30GHz	内存：32GB	操作系统：Windows10	软件平台：Visual Studio Code

#### 一、问题分析与求解思路

- **问题描述**：

​	对于给定的正整数N，在5分钟内生成一个N皇后的解，以文件形式存储，并验证是否为合法解。

- **思路分析**：

​	1.回溯法：从第一行开始按行放置，在当前行可用位置放置一个皇后，并更新放置该皇后带来的禁区，递归放置下一行的皇后，当某一	行没有可行位置时，向上一层回溯，还原上一层皇后带来的变化，并更改上一层的皇后位置，同时更新禁区，重新进入下一层，直至最	后一行皇后放置完成。

​	2.爬山法：先随机生成列不冲突的初始解，计算冲突数，再交换某两个皇后，若冲突数减少，则保留交换，继续寻找下一对皇后交换，	直至冲突数为0，输出可行解，若通过局部交换无法减少冲突数，随机重启，生成另一个初始解，重复上述过程。

​	3.构造法：通过数学推导得出N皇后的一个可行解。

经作者实验验证，回溯法无论是普通版本还是位运算版本，在给定时间内都只能跑到 N = 40 左右，而方法三虽然效率高且N的规模大，但与数学关联更强，为了更大的N的规模和更好的算法学习，本报告只讨论方法二。

#### 二、核心代码说明

- **my_rand()**      生成大随机数，普通的rand函数只能取到最大值32767，要运行更大规模的N，需要扩大随机数范围
- **random_start(int c)**      生成初始解，尽量较少初始冲突数，先放置n - c个不互相冲突的皇后，剩下的列不冲突地随机放置

```c
int random_start(int c) { //得到更好的初始解
    int m = n - c;
    for (int i = 0; i < n; i++)
        board[i] = i;
    memset(right_diag, 0, sizeof(int) * (2 * n - 1));
    memset(left_diag, 0, sizeof(int) * (2 * n - 1));
    int conflicts = 0;
    for (int i = 0; i < m; i++) {	//首先在空闲列中随机放置m个皇后,保证无冲突
        int j = i + my_rand() % (n - i);	//从[i, n)中选j,保证不影响已放置的皇后
        while (right_diag[i - board[j] + n - 1] > 0 || left_diag[i + board[j]] > 0)
            j = i + my_rand() % (n - i);
        swap(board[i], board[j]);
        right_diag[i - board[i] + n - 1]++;
        left_diag[i + board[i]]++;
    }
    for (int i = m; i < n; i++) {	 // 剩余c个皇后在空闲列中随便放置，并计算初始冲突数
        int j = i + my_rand() % (n - i);
        swap(board[i], board[j]);
        right_diag[i - board[i] + n - 1]++;
        left_diag[i + board[i]]++;
    }
    for (int i = 0; i < 2 * n - 1; i++) {
        conflicts += right_diag[i] > 1 ? right_diag[i] - 1 : 0;
        conflicts += left_diag[i] > 1 ? left_diag[i] - 1 : 0;
    }
    return conflicts;
}
```



- **conflict_num()**      计算当前皇后分布的冲突数

```c
int conflict_num() //计算冲突数
{
    int ans = 0;
    for (int i = 0; i < 2 * n - 1; i++)
    {
        ans += right_diag[i] > 1 ? right_diag[i] - 1 : 0;
        ans += left_diag[i] > 1 ? left_diag[i] - 1 : 0;
    }
    return ans;
}
```



- **swap_change(int i, int j)**      计算交换某两个皇后后冲突的减少数
- **update_state(int i, int j)**      用于交换两个皇后后更新冲突表
- **part_search()**      程序主体，通过交换皇后减少冲突数至0

```c
void part_search() {//减少冲突至0
    while (1) {
        int num = random_start(get_c(n));
        if (num == 0)
            return;
        //选择一个有冲突的与其他交换，可以有效的减少冲突数，减少冗余计算
        int change;
        for (int i = 0; i < n; i++) {
            if (right_diag[i - board[i] + n - 1] > 1 || left_diag[i + board[i]] > 1) {
                for (int j = 0; j < n; ++j) {
                    if (i != j) {
                        change = swap_change(i, j);
                        if (change > 0) {
                            update_state(i, j);
                            num = conflict_num();
                            //printf("%d\n", num);	//用于测试
                        }
                        if (num == 0)
                            return;
                    }
                }
            }
    	}
    }
}
```

- **print_queen()**       输出最终的可行解

####  三、测试，运行与分析

- **运行情况：**

以下规模生成的解经验证程序验证均合法，且在规定时间内。

|    N     |  8   |  80  | 800  | 8000 |  8万  | 80万  | 800万  | 5000万  |
| :------: | :--: | :--: | :--: | :--: | :---: | :---: | :----: | :-----: |
| **t(s)** |  0   |  0   |  0   |  0   | 0.062 | 0.842 | 22.252 | 171.717 |

- **分析：**

上面贴出的运行结果为最终优化版的结果，初始版本跑30000需要一小时左右。相对于初始版本，主要有三处优化。

**1.暴力穷举交换 → 选择性交换：**

在初代版本调试过程中，发现有很多次交换都没有使冲突数减少，导致有很多冗余计算；且交换一次冲突数减小量较小，一次减少一个或两个，导致运行效率不够高。改进之后，保证每次交换的两个皇后必定有一个是与其他有冲突的，可快速减少冲突数，减少交换次数。

**2.遍历棋盘计算冲突数 → 引入冲突表：**

利用同一主对角线上的点纵横坐标之差相等，同一副对角线上的点纵横坐标之和相等的数学规律，遍历一次棋盘就可以快速计算出冲突数，且交换前后的冲突数变化也可以直接计算出来，减少了计算冲突数的过程。

**3.完全随机生成初始解 → 尽量减少冲突数地生成初始解：**

初代版本调试过程中发现随机生成的初始解冲突数太多，虽然冲突数减少的很快，但减少到零的时间还是太长，于是优化生成初始解的函数，保证初始冲突数小于给定值c，先生成n - c个互不冲突的皇后，剩下c个像原来一样列不冲突即可。

- **体会：**

当然，优化的过程并不是一帆风顺的，中间有很多未考虑到的bug，例如：生成随机数的问题，rand函数最大32767，所以初代版本跑到32768就跑不出来了，检查了半天最后发现是随机数不够大了；简单改造了随机数生成函数后发现跑到65536（32768*2）又不行了，差点以为是效率问题跑的太慢，测试发现随机数0和65535都可以取到，最后发现了原因，简单的增加了随机数的最小值和最大值是有问题的，中间有空缺，程序卡在了生成初始解的地方。

#### 四、总结

1.算法的优化能指数级提高程序效率，初始版本30000需要1小时，而优化后1秒不到。

2.bug有时候会藏在意想不到的小地方，例如大随机数的生成。

3.新的算法增加了：爬山法。

#### 五、附件

- **debug.c**      函数测试程序
- **climb_Nqueen.c**      主体程序，生成可行解
- **test_queen.c**      验证生成的解是否合法
- **solutions.txt**      储存生成的解

另附：
queen.c      回溯法普通版
fast.c      回溯法位运算版







